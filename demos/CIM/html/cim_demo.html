
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Channel Identification Machines</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-07-20"><meta name="DC.source" content="cim_demo.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Channel Identification Machines</h1><!--introduction--><p>This demo illustrates a formal methodology for identifying a channel in a system consisting of a communication channel in cascade with an asynchronous sampler. In particular, the channel is modeled as a multidimensional filter, while models of asynchronous sampler are taken from neuroscience and communications and includes integrate-and-fire (IAF) neurons, asynchronous delta-sigma modulators (ASDM), and general oscillators in cascade with zero-crossing detectors.</p><p>The code below reproduces results presented in [1] and can be used to generate Figs. 5-9 and Figs. 11-13 in [1]. The employed filter was taken from [2].</p><p>The code is structured as follows. First, we present a step-by-step demo of Fig.5: (1) encode input signals (2) specify filter(s) (3) filer input signal(s) (4) encode filter output using an asynchronous sampler (5) identify the filter(s)</p><p>We provide the code for each step together with the code for plotting the results. Then we declare functions for each of the above steps and package these functions into a MATLAB class 'cim_utility' for repetitive usage. The script for reproducing Figs. 6-9 and Figs. 11-13 is contained in that MATLAB class.</p><div><ul><li><i>Author: Yevgeniy B. Slutskiy <a href="ys2146@columbia.edu">ys2146@columbia.edu</a></i></li><li><i>Revision Author: Chung-Heng Yeh <a href="chyeh@ee.columbia.edu">chyeh@ee.columbia.edu</a></i></li><li><i>Bionet Group, Columbia University</i></li><li><i>Copyright 2012-2014 Yevgeniy B. Slutskiy and Chung-Heng Yeh</i></li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialize the demo</a></li><li><a href="#3">Specify the Ideal IAF neuron</a></li><li><a href="#4">Create the band-limited Stimulus</a></li><li><a href="#7">Specify the filter <i>h</i> to be used</a></li><li><a href="#8">Compute the projection Ph onto the RKHS</a></li><li><a href="#10">Filter the input signal</a></li><li><a href="#12">Encode the filter output  with an IAF neuron</a></li><li><a href="#15">Recover the filter</a></li><li><a href="#20">Reproduce Fig.5 of [1]</a></li><li><a href="#22">Reproduce Fig.6 of [1]</a></li><li><a href="#31">Reproduce Fig.7 of [1]</a></li><li><a href="#40">Reproduce Fig.8 of [1]</a></li><li><a href="#51">Reproduce Fig.9 of [1]</a></li><li><a href="#56">Reproduce Fig.11 of [1]</a></li><li><a href="#67">Reproduce Fig.12 of [1]</a></li><li><a href="#78">Reproduce Fig.13 of [1]</a></li><li><a href="#89">Reference</a></li></ul></div><h2>Initialize the demo<a name="1"></a></h2><pre class="codeinput">clc; clear <span class="string">all</span>; close <span class="string">all</span>;                                           <span class="comment">% reset the MATLAB workspace</span>
set(0,<span class="string">'defaulttextinterpreter'</span>,<span class="string">'Latex'</span>);                             <span class="comment">% set the default text interpreter to latex</span>
addpath(<span class="string">'../../cim'</span>);                                                <span class="comment">% set the default path of CIM functions</span>

tic_demo = tic;                                                      <span class="comment">% start the demo timer</span>
tic_fig5 = tic;                                                      <span class="comment">% start the demo timer for Fig. 5</span>
</pre><p>Define function handles for repetitive usage</p><pre class="codeinput">e_l = @(m,t,L,W,T) exp(1j*m*W/L*t)/sqrt(T);                          <span class="comment">% declare basis of the RKHS of trigonometric polynomials</span>
filter = @(t,T1,T2,a) (t&gt;=T1 &amp; t&lt;T2).*(3*a*exp(-a*t)<span class="keyword">...</span><span class="comment">              % the filter taken from [2]</span>
          .*((a*t).^3/factorial(3)-(a*t).^5/factorial(5)));
tri_ker = @(t,L,W,T) (2*L+1)/T*sinc((2*L+1)*W/(2*L)*t/pi)<span class="keyword">...</span><span class="comment">         % kernel of the RKHS</span>
           ./sinc(W/(2*L)*t/pi);
</pre><h2>Specify the Ideal IAF neuron<a name="3"></a></h2><pre class="codeinput">delta = 0.005;                                                       <span class="comment">% set the threshold</span>
bias  = 0.3;                                                         <span class="comment">% set the bias</span>
kappa = 1;                                                           <span class="comment">% set the capacitance</span>
sigma_delta = 0;                                                     <span class="comment">% set the variance of random thresholds</span>
</pre><h2>Create the band-limited Stimulus<a name="4"></a></h2><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 27111987);
rand(<span class="string">'state'</span>, 19550206)
</pre><p>Specify the order L and bandwidth W for the space of trigonometric polynomials</p><pre class="codeinput">L = 5;                                                               <span class="comment">% set the order of the space (number of exponentials)</span>
f = 25;                                                              <span class="comment">% set the input signal bandwidth, [Hz]</span>
W = 2*pi*f;                                                          <span class="comment">% calculate the bandwidth in radians</span>
T = 2*pi*L/W;                                                        <span class="comment">% calculate the period of the input signal</span>
</pre><p>Synthesize an input signal u(t) from random coefficients u_l, l=-L,...,L. Note that u is defined on an interval [-T/2, T/2]. However, MATLAB assumes that the signal is defined on [0,T] when using the Fourier transform. To fix this, ifftshift is used to get the correct result. Since the signal u(t) is real, u_{-l} = conj(u_l), i.e., positive Fourier coefficients are complex conjugates of the negative coefficients and the zero-frequency, or DC term, is real (fundamental result of the Fourier transform).</p><pre class="codeinput">dt = 1e-5;                                                           <span class="comment">% set the time step, [s]</span>
t  = -T/2:dt:T/2;                                                    <span class="comment">% set the time course of the signal</span>
u_l = (randn(1,2*L+1)+1i*randn(1,2*L+1));                            <span class="comment">% generate random signal coefficients</span>
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            <span class="comment">% u_{-l} = conj(u_l)</span>
u_l(:,L+1) = randn(1,1);                                             <span class="comment">% DC-term is real</span>
u_l_pad = [u_l(L+1:end) zeros(1,numel(t)-2*L-1) u_l(1:L)];           <span class="comment">% set the frequency component outside bandwidth to zero</span>
u = real(ifftshift(ifft(u_l_pad)))/sqrt(T)*numel(t);                 <span class="comment">% synthesize the signal using inverse Fourier transform</span>
u = u/max(abs(u));                                                   <span class="comment">% normalize the signal</span>
</pre><h2>Specify the filter <i>h</i> to be used<a name="7"></a></h2><p>Generate a filter h according to Adelson and Bergen [2]. h has a temporal support on the interval [T1, T2] with T2-T1&lt;T. However, since the filter projection is periodic with period T, the filter is defined on [-T/4, 3*T/4] with zero response outside [T1, T2] for comparison purposes.</p><pre class="codeinput">T1 = 0; T2 = 0.1;                                                    <span class="comment">% specify T1 and T2</span>
a = 200;                                                             <span class="comment">% set the filter parameter</span>
t_filt = -T/4:dt:T*3/4;                                              <span class="comment">% set the time course of the filter, [s]</span>
h = filter(t_filt,T1,T2,a);
</pre><h2>Compute the projection Ph onto the RKHS<a name="8"></a></h2><p>Generate the reproducing kernel for the space of trigonometric polynomials (see Def. 1 in [1]). Since functions in the RKHS are periodic, use the circular convolution to compute Ph</p><pre class="codeinput">K  = tri_ker(t_filt-t_filt(1),L,W,T);                                <span class="comment">% get the reproducing kernel</span>
Ph = dt*cconv(h,K,numel(t_filt));                                    <span class="comment">% find Ph by convolving h with K</span>
</pre><p>Plot the filter h and its projection Ph.</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    plot(t_filt,h,<span class="string">'--k'</span>,t_filt,Ph,<span class="string">'r'</span>);
    xlabel(<span class="string">'Time, [s]'</span>);ylabel(<span class="string">'Amplitude'</span>);xlim([t_filt(1)  t_filt(end)]);
    title(<span class="string">'Filter and its projection'</span>);
    legend(<span class="string">'$h$'</span>,<span class="string">'$\mathcal{P}h$'</span>)
</pre><img vspace="5" hspace="5" src="cim_demo_01.png" alt=""> <h2>Filter the input signal<a name="10"></a></h2><p>Similarly, use circular convolution to comptue the filter output. Use only the causal part of the filter.</p><pre class="codeinput">v = dt*cconv(h(t_filt&gt;=0),u,numel(u));                               <span class="comment">% convolve u with h</span>
</pre><p>Plot the input signal and the filter output.</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    subplot(2,1,1);
        plot( t-t(1), u );
        ylabel(<span class="string">'Amplitude'</span>);xlim([0 t(end)-t(1)]);set(gca,<span class="string">'xticklabel'</span>,[]);
        title(<span class="string">'(a)$\qquad$Input signal u(t)'</span>);
        legend([<span class="string">'$\Omega = 2\pi\cdot$'</span> num2str(f) <span class="string">'rad/s, $L = '</span> num2str(L) <span class="string">'\quad$'</span>],<span class="keyword">...</span>
                <span class="string">'location'</span>,<span class="string">'East'</span>);
    subplot(2,1,2);
        plot( t-t(1), v );
        ylabel(<span class="string">'Amplitude'</span>);xlim([0 t(end)-t(1)]);xlabel(<span class="string">'Time, [s]'</span>)
        title(<span class="string">'(b)$\qquad$Filter Output v(t)'</span>);
</pre><img vspace="5" hspace="5" src="cim_demo_02.png" alt=""> <h2>Encode the filter output  with an IAF neuron<a name="12"></a></h2><p>The integrate-and-fire (IAF) neuron is used as an instance of an asynchronous sampler, and exemplifies the encoding process in which the filter output is encoded into a spike sequence. Although the threshold is constant in this case, a more general implementation with random thresholds is provided below.</p><pre class="codeinput">spikes  = zeros(size(t));                                            <span class="comment">% allocate a vector for the spike train</span>
voltage = zeros(size(t));                                            <span class="comment">% allocate a vector for the membrane voltage</span>
delta_v = delta + sigma_delta*randn();                               <span class="comment">% allocate a vector for random thresholds</span>
voltage(1) = 0.9*delta_v*rand();                                     <span class="comment">% initialize the membrane voltage</span>
</pre><p>Perform numerical integration using the trapezoidal method.</p><pre class="codeinput"><span class="keyword">for</span> i = 2:numel(t)
    <span class="comment">% update the membrane voltage</span>
    voltage(i) = voltage(i-1) + dt/kappa*(bias+0.5*(v(i)+v(i-1)));
    <span class="comment">% if above threshold</span>
    <span class="keyword">if</span> voltage(i) &gt;= delta_v(end)
        voltage(i) = 0;                                              <span class="comment">% reset the membrane voltage</span>
        spikes(i)  = 1;                                              <span class="comment">% record spike</span>
        delta_v    = [delta_v delta+sigma_delta*randn()];            <span class="comment">% get a new random threshold</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Plot the encoding result.</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    subplot(311);
        plot(t-t(1),u);
        ylabel(<span class="string">'Amplitude'</span>);xlim([0 t(end)-t(1)]);set(gca,<span class="string">'xticklabel'</span>,[]);
        title(<span class="string">'(a)$\qquad$Input signal u(t)'</span>);
        legend([<span class="string">'$\Omega = 2\pi\cdot$'</span> num2str(f) <span class="string">'rad/s, $L = '</span> num2str(L) <span class="string">'\quad$'</span>],<span class="keyword">...</span>
                <span class="string">'location'</span>,<span class="string">'East'</span>);
    subplot(312);
        plot(t-t(1), voltage,<span class="string">'-b'</span>);
        hold <span class="string">on</span>; plot( [0 t(end)-t(1)], delta*ones(1,2),<span class="string">'--r'</span>);
        hold <span class="string">on</span>; plot(t(logical(spikes))-t(1), delta_v(1:end-1),<span class="string">'or'</span>,<span class="keyword">...</span>
                      <span class="string">'linewidth'</span>, 1, <span class="string">'markersize'</span>,6, <span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>);
        ylabel(<span class="string">'Membrane Potential'</span>);set(gca,<span class="string">'xticklabel'</span>,[]);
        title(<span class="string">'(b)$\qquad$Integrator output vs. Time'</span>);
        legend(<span class="string">'$\int_{t_k}^{t}(u\ast h)(s)ds,\,\forall k\qquad$'</span>,<span class="keyword">...</span>
               [<span class="string">'$\delta = '</span> num2str(delta) <span class="string">'$'</span>], <span class="keyword">...</span>
               <span class="string">'$\int_{t_k}^{t}(u\ast h)(s)ds=\delta$'</span>,<span class="string">'Location'</span>,<span class="string">'southeast'</span>);
        axis([0 t(end)-t(1) -0.1*delta 1.2*delta]);
    subplot(313);
        stem(t(spikes==1)-t(1), 1.1*ones(size(find(spikes==1))), <span class="string">'^k'</span>, <span class="string">'filled'</span>);
        box <span class="string">on</span>; set(gca,<span class="string">'yticklabel'</span>,[],<span class="string">'ytick'</span>,[]);
        title(<span class="string">'(c)$\qquad$IAF spike train for u(t)'</span>);
        xlabel(<span class="string">'Time, [s]'</span>); axis([0 t(end)-t(1)  0 1.2]);
        legend([<span class="string">'Spikes, $n = '</span> num2str(sum(spikes),<span class="string">'%3.0f'</span>) <span class="string">'\quad$'</span>],<span class="keyword">...</span>
                <span class="string">'Location'</span>,<span class="string">'East'</span>);
</pre><img vspace="5" hspace="5" src="cim_demo_03.png" alt=""> <h2>Recover the filter<a name="15"></a></h2><p>The identification algorithm is based on Lemma 1 and Lemma 2 in [1]. The notation follows [1].</p><pre class="codeinput">tk = t(spikes==1)';                                                  <span class="comment">% get the spike times</span>
total_spikes_used = numel(tk)-1;                                     <span class="comment">% compute the number of spikes used for identification</span>
</pre><p>Compute the measurement vector q (see Sec. 3.1 in [1]).</p><pre class="codeinput">q = kappa*delta - bias*diff(tk);                                     <span class="comment">% Eq.(2) in [1]</span>
</pre><p>Compute the Phi matrix. Since u_{-l} = conj(u_l) for real signals, only half of the matrix needs to be computed. Note that 'l' in Eq.(7) is replaced by 'm' to avoid confusion between '1' and 'l'.</p><pre class="codeinput">Phi = zeros(total_spikes_used,2*L+1);                                <span class="comment">% allocate Phi matrix</span>
u_l = fft(u)*sqrt(T)/numel(u);                                       <span class="comment">% reconstruct the signal coefficients</span>
<span class="keyword">for</span> m=-L:0
    <span class="keyword">if</span> m == 0
        Phi(:,L+1) = u_l(1)*diff(tk);                                <span class="comment">% the DC component</span>
    <span class="keyword">else</span>
        Phi(:,m+L+1) = u_l(end+m+1)*sqrt(T)/(1j*m*W/L)*<span class="keyword">...</span>
                       (e_l(m,tk(2:end),L,W,T)-e_l(m,tk(1:end-1),L,W,T));
    <span class="keyword">end</span>
<span class="keyword">end</span>
Phi(:,L+2:end) = conj(Phi(:,L:-1:1));
</pre><p>Recover the <b>h</b> vector by multiplying the pseudo inverse of Phi with q. A cutoff of 1e-9 is set to eliminate infinitesimal singular values.</p><pre class="codeinput">bold_h = transpose(pinv(Phi,1e-9)*q);                                <span class="comment">% Note that bold_h is a column vector</span>
</pre><p>Reconstruct the projection of the filter Ph. The reconstruction algorithm is based on the inverse Fourier transform, and is similar to what has been shown for generating  an input signal. For convenience, the reconstruction algorithm is implemented as a function.</p><pre class="codeinput">h_rec = cim_utility.synthesizeSignal(t,t_filt,bold_h,L,T);
</pre><h2>Reproduce Fig.5 of [1]<a name="20"></a></h2><p>The script for plotting Fig. 5 of [1] is wrapped in a function to save space.</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,<span class="keyword">...</span>
        h,Ph,t,u,v,spikes,voltage,{delta_v},h_rec,total_spikes_used);
</pre><img vspace="5" hspace="5" src="cim_demo_04.png" alt=""> <p>Get running time for Fig.5.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 5: '</span>, toc(tic_fig5));
</pre><pre class="codeoutput">Running time for Fig. 5: 0' 14.2"
</pre><h2>Reproduce Fig.6 of [1]<a name="22"></a></h2><p>Next, we demonstrate the identification of the filter projected onto the RKHS with bandwidth f=100Hz and order L=20.</p><pre class="codeinput">tic_fig6 = tic;                                                      <span class="comment">% start the demo timer for Fig. 6</span>
</pre><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 27111987);
rand(<span class="string">'state'</span>, 19550206);
</pre><p>Generate the input signals.</p><pre class="codeinput">L  = 20;                                      	                     <span class="comment">% set the order of the space (number of basis)</span>
f  = 100;                                                            <span class="comment">% set the input signal bandwidth, [Hz]</span>
W  = 2*pi*f;                                                         <span class="comment">% calculate the bandwidth in radians</span>
T  = 2*pi*L/W;                                                       <span class="comment">% calculate the period of the input signal</span>
n  = 4;                                                              <span class="comment">% set the number of input signals</span>
dt = 1e-5;                                                           <span class="comment">% set the time step, [s]</span>
t  = -T/2:dt:T/2;                                                    <span class="comment">% set the time course of the input signals, [s]</span>
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              <span class="comment">% generate random signal coefficients</span>
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            <span class="comment">% u_{-l} = conj(u_l)</span>
u_l(:,L+1) = randn(n,1);                                             <span class="comment">% make the DC-term real</span>
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,<span class="string">'Normalize'</span>);      <span class="comment">% synthesize the input signals</span>
</pre><p>Create the filter and Compute the filter projection.</p><pre class="codeinput">t_filt = -T/4:dt:T*3/4;                                              <span class="comment">% set the time course of the filter, [s]</span>
h      = filter(t_filt,T1,T2,a);                                     <span class="comment">% create the filter</span>
K      = tri_ker( t_filt-t_filt(1), L, W, T);                        <span class="comment">% get the reproducing kernel K</span>
Ph     = dt*cconv(h,K,numel(t_filt));                                <span class="comment">% find the projection Ph by convolving h with K</span>
</pre><p>Filter the input signals.</p><pre class="codeinput">v = zeros(size(u));                                                  <span class="comment">% allocate a matrix for the filter output</span>
<span class="keyword">for</span> i=1:n
    v(i,:) = dt*cconv(h(t_filt&gt;=0),u(i,:),numel(t));                 <span class="comment">% convolve each input signal with h</span>
<span class="keyword">end</span>
</pre><p>Encode the filter output.</p><pre class="codeinput">s = zeros(size(u));                                                  <span class="comment">% allocate a matrix for the spike train</span>
voltage = zeros(size(u));                                            <span class="comment">% allocate a matrix for the membrane voltage</span>
delta_v = cell(n,1);                                                 <span class="comment">% allocate a vector for random thresholds</span>
<span class="keyword">for</span> i=1:n
    <span class="comment">% encode the output of the filter using an ideal IAF neuron</span>
    [s(i,:), voltage(i,:), delta_v{i}] = ideal_iaf_rt_encode(<span class="keyword">...</span>
        v(i,:), t, bias, delta, kappa);
<span class="keyword">end</span>
</pre><p>Identify the filter.</p><pre class="codeinput">[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(<span class="keyword">...</span>
    t, t_filt, u, W, L, bias, delta, kappa, s);
</pre><pre class="codeoutput">Number of spikes needed: 42
Number of spikes used: 48
</pre><p>Generate Fig.6 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,<span class="keyword">...</span>
        h,Ph,t,u,v,s,voltage,delta_v,h_rec,total_spikes_used);
</pre><img vspace="5" hspace="5" src="cim_demo_05.png" alt=""> <p>Get running time for Fig.6.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 6: '</span>, toc(tic_fig6));
</pre><pre class="codeoutput">Running time for Fig. 6: 0' 11.6"
</pre><h2>Reproduce Fig.7 of [1]<a name="31"></a></h2><p>Now, we consider a special case when the channel does not alter the input signal, i.e., when the filter is the Dirac delta function.</p><pre class="codeinput">tic_fig7 = tic;                                                      <span class="comment">% start the demo timer for Fig. 7</span>
</pre><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 19871127);
rand(<span class="string">'state'</span>, 19550206);
</pre><p>Generate the input signals.</p><pre class="codeinput">L  = 10;                                      	                     <span class="comment">% set the order of the space (number of basis)</span>
f  = 50;                                                             <span class="comment">% set the input signal bandwidth, [Hz]</span>
W  = 2*pi*f;                                                         <span class="comment">% calculate the bandwidth in radians</span>
T  = 2*pi*L/W;                                                       <span class="comment">% calculate the period of the input signal</span>
n  = 2;                                                              <span class="comment">% set the number of input signals</span>
dt = 1e-5;                                                           <span class="comment">% set the time step, [s]</span>
t  = -T/2:dt:T/2;                                                    <span class="comment">% set the time course of the input signals, [s]</span>
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              <span class="comment">% generate random signal coefficients</span>
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            <span class="comment">% u_{-l} = conj(u_l)</span>
u_l(:,L+1) = randn(n,1);                                             <span class="comment">% make the DC-term real</span>
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,<span class="string">'Normalize'</span>);      <span class="comment">% synthesize the input signals</span>
</pre><p>Specify the filter as the Dirac delta fcuntion.</p><pre class="codeinput">t_filt = -T/4:dt:T*3/4;                                              <span class="comment">% set the time course of the filter, [s]</span>
d      = ( abs(t_filt) &lt; dt/2 )/dt;                                  <span class="comment">% specify the filter as the Dirac delta function</span>
Ph     = tri_ker( t_filt, L, W, T);                                  <span class="comment">% the filter projection is simply the kernel of the space</span>
</pre><p>Filter the input signal. Since the filter is the Dirac delta function, the filter output is simply a copy of the input signal.</p><pre class="codeinput">v = u;                                                               <span class="comment">% set the filter output equal to the input</span>
</pre><p>Encode the filter output.</p><pre class="codeinput">s = zeros(size(u));                                                  <span class="comment">% allocate a matrix for the spike train</span>
voltage = zeros(size(u));                                            <span class="comment">% allocate a matrix for the membrane voltage</span>
delta_v = cell(n,1);                                                 <span class="comment">% allocate a vector for random thresholds</span>
<span class="keyword">for</span> i=1:n
    <span class="comment">% encode the output of the filter using an ideal IAF neuron</span>
    [s(i,:), voltage(i,:), delta_v{i}] = ideal_iaf_rt_encode(<span class="keyword">...</span>
        v(i,:), t, bias, delta, kappa);
<span class="keyword">end</span>
</pre><p>Identify the filter.</p><pre class="codeinput">[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(<span class="keyword">...</span>
    t, t_filt, u, W, L, bias, delta, kappa, s);
</pre><pre class="codeoutput">Number of spikes needed: 22
Number of spikes used: 28
</pre><p>Generate Fig.7 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,<span class="keyword">...</span>
        d,Ph,t,u,v,s,voltage,delta_v,h_rec,total_spikes_used);
</pre><img vspace="5" hspace="5" src="cim_demo_06.png" alt=""> <p>Get running time for Fig.7.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 7: '</span>, toc(tic_fig7));
</pre><pre class="codeoutput">Running time for Fig. 7: 0' 11.0"
</pre><h2>Reproduce Fig.8 of [1]<a name="40"></a></h2><p>Now, we consider a circuit comprised of a channel in cascade with a nonlinear dynamical system that has a stable limit cycle. In particular, the employed nonlinear dynamic system belongs to the family of van der Pol oscillator.</p><pre class="codeinput">tic_fig8 = tic;                                                      <span class="comment">% start the demo timer for Fig. 8</span>
</pre><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 19871127);
rand(<span class="string">'state'</span>, 19550206);
</pre><p>Generate the input signal.</p><pre class="codeinput">L  = 25;                                                             <span class="comment">% set the order of the space (number of exponentials)</span>
f  = 50;                                                             <span class="comment">% set the input signal bandwidth, [Hz]</span>
W  = 2*pi*f;                                                         <span class="comment">% calculate the bandwidth in radians</span>
T  = 2*pi*L/W;                                                       <span class="comment">% calculate the period of the input signal</span>
n  = 4;                                                              <span class="comment">% set the number of input signals</span>
dt = 2e-6;                                                           <span class="comment">% set the time step, [s]</span>
t  = -T/2:dt:T/2;                                                    <span class="comment">% set the time course of the input signals, [s]</span>
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              <span class="comment">% generate random signal coefficients</span>
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            <span class="comment">% the positive and negative component is conjugate to each other</span>
u_l(:,L+1) = randn(n,1);                                             <span class="comment">% set DC-term to real</span>
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,<span class="string">'Normalize'</span>);      <span class="comment">% synthesize the input signals</span>
</pre><p>Create the filter and Compute the filter projection.</p><pre class="codeinput">t_filt = -T/4:dt:T*3/4;                                              <span class="comment">% set the time course of the filter, [s]</span>
h      = filter(t_filt,T1,T2,a);                                     <span class="comment">% create the filter</span>
K      = tri_ker( t_filt-t_filt(1), L, W, T);                        <span class="comment">% get the reproducing kernel K</span>
Ph     = dt*cconv(h,K,numel(t_filt));                                <span class="comment">% find the projection Ph by convolving h with K</span>
</pre><p>Filter the input signal.</p><pre class="codeinput">v = zeros(size(u));                                                  <span class="comment">% allocate a matrix for the filter output</span>
<span class="keyword">for</span> i=1:n
    v(i,:) = dt*cconv(h(t_filt&gt;=0),u(i,:),numel(t));                 <span class="comment">% convolve each input signal with h</span>
<span class="keyword">end</span>
</pre><p>Specify the van der Pol oscillator. Note that the oscillator parameters are specified with time unit as millisecond. As a result, the time course of the oscillator is converted from second to millisecond.</p><pre class="codeinput">mu   = 20;                                                           <span class="comment">% set the dumping factor</span>
bias = 1;                                                            <span class="comment">% set the bias</span>
<span class="comment">% set the function handle for the system equation of the van der Pol oscillator</span>
van_der_pol = @(u,y) [mu*(u+bias)*(y(1)-1/3*y(1)^3-y(2)); (u+bias)*y(1)/mu];
</pre><p>Find the limit cycle of the employed van der Pol oscillator. In doing so, at each cycle, we record the 'spike' point on the phase plane, and compare the 'spike' point with the previous one. When the 'spike' point converges to a certain point, it implies that the system oscillates on a particular limit cycle.</p><pre class="codeinput">spike_y = Inf(2,1);                                                  <span class="comment">% initialize the spike point</span>
y = repmat([0.5; 0],1,3);                                            <span class="comment">% initialize the state variables of the oscillator</span>
counter = 0;                                                         <span class="comment">% set the counter</span>
<span class="keyword">while</span> abs(spike_y(1) - y(1,2)) &gt; 1e-8
    y(:,3) = y(:,2) + 1e3*dt*van_der_pol(0,y(:,2));                  <span class="comment">% update the state variables of the oscillator</span>
    <span class="keyword">if</span> y(1,1) &lt; y(1,2) &amp;&amp; y(1,2) &gt; y(1,3)                            <span class="comment">% spike detection</span>
        spike_y = y(:,2);                                            <span class="comment">% record the spike point when spike detected</span>
        period  = counter;                                           <span class="comment">% record the period of the present cycle</span>
        counter = 0;                                                 <span class="comment">% reset the counter</span>
    <span class="keyword">end</span>
    y(:,1:2) = y(:,2:3);                                             <span class="comment">% pass the current states to post states</span>
    counter = counter + 1;                                           <span class="comment">% increase the counter by 1</span>
<span class="keyword">end</span>
lc = zeros(size(y,1),period);                                        <span class="comment">% allocate memory for the limit cycle</span>
lc(:,1) = spike_y;                                                   <span class="comment">% set the 'spike' point of the limit cycle</span>
<span class="keyword">for</span> i = 2:counter
    lc(:,i) = lc(:,i-1) + 1e3*dt*van_der_pol(0,lc(:,i-1));           <span class="comment">% compute the limit cycle at each time step</span>
<span class="keyword">end</span>
</pre><p>Encode the filter output using the van der Pol oscillator. We provide a generic nonlinear encoder in which the van der Pol oscillator is embedded. The van der Pol oscillator can be replaced by any other dynamic system which has a stable limit cycle and an analytic system equation.</p><pre class="codeinput">y1 = zeros(n,numel(t));                                              <span class="comment">% allocate memory for the first state variable</span>
y2 = zeros(n,numel(t));                                              <span class="comment">% allocate memory for the second state variable</span>
s = zeros(n,numel(t));                                               <span class="comment">% allocate memory for the spike sequence</span>
<span class="keyword">for</span> i = 1:n
    rnd_init = lc(:,round(1 + period*rand));                         <span class="comment">% set the oscillator at a random point of the limit cycle</span>
    <span class="comment">% encode the filter output using the van der Pol oscillator</span>
    [s(i,:), y1(i,:), y2(i,:)] = nonlinear_sys_encode(<span class="keyword">...</span>
        v(i,:),1e3*t,van_der_pol,rnd_init);
<span class="keyword">end</span>
</pre><p>Identify the filter.</p><pre class="codeinput">h_rec = identify_h_ideal_iaf_trig( t, t_filt, u, W, L, bias, period*dt, 1, s);
</pre><pre class="codeoutput">Number of spikes needed: 52
Number of spikes used: 56
</pre><p>Generate Fig. 8 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig8(T1,T2,T,f,W,L,mu,bias,dt,lc,<span class="keyword">...</span>
                         t_filt,h,Ph,t,u,v,y1,y2,s,h_rec);
</pre><img vspace="5" hspace="5" src="cim_demo_07.png" alt=""> <p>Get running time for Fig.8.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 8: '</span>, toc(tic_fig8));
</pre><pre class="codeoutput">Running time for Fig. 8: 0' 48.4"
</pre><h2>Reproduce Fig.9 of [1]<a name="51"></a></h2><p>To provide intuition about the relationship between the filter and the filter projection, we compare the two in both time and frequency domains for several choices of the RKHS (different orders L and bandwidths W).</p><pre class="codeinput">tic_fig9 = tic;                                                      <span class="comment">% start the demo timer for Fig. 9</span>
</pre><p>Specify the filter h to be used.</p><pre class="codeinput">dt = 1e-5;                                                           <span class="comment">% set the time step, [s]</span>
t_filt = -1:dt:1;                                                    <span class="comment">% set the time course of the filter</span>
h = filter(t_filt,T1,T2,a);                                          <span class="comment">% get the filter</span>
</pre><p>Compute the filter projection onto the RKHS for multiple values of bandwidth W and order L.</p><pre class="codeinput">T   = [0.2 0.5];                                                     <span class="comment">% set the period of the space</span>
f_v = [20 50 100];                                                   <span class="comment">% set the bandwidth of the space</span>
Ph_cell = cell(length(f_v), length(T));                              <span class="comment">% allocate a cell for Ph</span>
<span class="keyword">for</span> i=1:numel(f_v)
    W = 2*pi*f_v(i);                                                 <span class="comment">% calculate the bandwidth in radians</span>
    <span class="keyword">for</span> j = 1:numel(T)
        L = f_v(i)*T(j);                                             <span class="comment">% set the order of the space</span>
        K = tri_ker(t_filt,L,W,T(j));                                <span class="comment">% get the reproducing kernel K</span>
        Ph_cell{i,j} = dt*cconv( h, K, numel(t_filt) );              <span class="comment">% compute the filter projection onto the kernel</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Generate Fig.9 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig9(t_filt,dt,h,Ph_cell,f_v,T);
</pre><img vspace="5" hspace="5" src="cim_demo_08.png" alt=""> <p>Get running time for Fig.9.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 9: '</span>, toc(tic_fig9));
</pre><pre class="codeoutput">Running time for Fig. 9: 0' 30.6"
</pre><h2>Reproduce Fig.11 of [1]<a name="56"></a></h2><p>We now demonstrate the channel identification for a MISO circuit consisting of three filters in cascade with an asynchronous sigma-delta modulator.</p><pre class="codeinput">tic_fig11 = tic;                                                     <span class="comment">% start the demo timer for Fig. 11</span>
</pre><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 19871127);
rand(<span class="string">'state'</span>, 19550206);
</pre><p>Set the  parameters of IAF neuron.</p><pre class="codeinput">delta = 0.0025;                                                      <span class="comment">% set the Schmitt trigger threshold</span>
bias  = 0.9;                                                         <span class="comment">% set the bias</span>
kappa = 1;                                                           <span class="comment">% set the integrator capacitance</span>
</pre><p>Generate the input signals. Five sets of input signal are randomly generated. Each set consists of three different signals, each of which is fed into one of three filters.</p><pre class="codeinput">L  = 20;                                                             <span class="comment">% set the order of the space (number of exponentials)</span>
f  = 100;                                                            <span class="comment">% set the input signal bandwidth, [Hz]</span>
W  = 2*pi*f;                                                         <span class="comment">% calculate the bandwidth in radians</span>
T  = 2*pi*L/W;                                                       <span class="comment">% calculate the period of the input signal</span>
n  = 5;                                                              <span class="comment">% set the number of input signal sets</span>
dt = 1e-6;                                                           <span class="comment">% set the time step, [s]</span>
t  = -T/2:dt:T/2;                                                    <span class="comment">% set the time course of the input signals, [s]</span>
u = zeros(3,length(t),n);                                            <span class="comment">% initialize the input signals</span>
u_l = randn(3,2*L+1,n)+1i*randn(3,2*L+1,n);                          <span class="comment">% generate random signal coefficients</span>
<span class="keyword">for</span> i=1:n
    u_l(:,1:L,i) = conj(u_l(:,end:-1:end-L+1,i));                    <span class="comment">% u_{-l} = conj(u_l)</span>
    u_l(:,L+1,i) = randn(3,1);                                       <span class="comment">% make DC-term real</span>
    u(:,:,i) = cim_utility.synthesizeSignal(t-t(1),t,u_l(:,:,i),<span class="keyword">...</span><span class="comment">  % synthesize the input signal</span>
                 L,T,<span class="string">'normalize'</span>);
<span class="keyword">end</span>
</pre><p>Create three Filters. The first one is same as considered above. The second one is the delayed version of the first filter. The last one is inverted version of the first one.</p><pre class="codeinput">t_filt = -T/4:dt:T*3/4;                                              <span class="comment">% set the time course of the filter, [s]</span>
beta = 20e-3;                                                        <span class="comment">% set the delay of the second filter</span>
h = zeros(3,numel(t_filt));                                          <span class="comment">% initialize the filter bank</span>
h(1,:) = filter(t_filt,T1,T2,a);                                     <span class="comment">% get the filter h1</span>
h(2,:) = filter(t_filt-beta,T1,T2,a);                                <span class="comment">% get the delayed version of h1</span>
h(3,:) = -filter(t_filt,T1,T2,a);                                    <span class="comment">% get the inverted version of h2</span>
</pre><p>Compute the projection of three filters</p><pre class="codeinput">K  = tri_ker( t_filt-t_filt(1), L, W, T);                            <span class="comment">% compute the reproducing kernel K</span>
Ph = zeros(size(h));                                                 <span class="comment">% initialize the filter projection</span>
<span class="keyword">for</span> i = 1:size(h,1)
    Ph(i,:) = dt*cconv(h(i,:),K,numel(t_filt));                      <span class="comment">% compute projection for each filter</span>
<span class="keyword">end</span>
</pre><p>Filter the input signals.</p><pre class="codeinput">v = zeros(n,numel(t));                                               <span class="comment">% allocate a matrix for the filter output</span>
<span class="keyword">for</span> i=1:n
    <span class="keyword">for</span> j=1:size(h,1)
        <span class="comment">% the input to the ASDM is the summation of the output of three filters</span>
        v(i,:) = v(i,:) + dt*cconv( h(j,t_filt&gt;=0), u(j,:,i), numel(t) );
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Encode filter output v.</p><pre class="codeinput">z = zeros(n,numel(t));                                               <span class="comment">% allocate a matrix for the ASDM phase</span>
voltage = zeros(n,numel(t));                                         <span class="comment">% allocate a matrix for the ASDM voltage</span>
<span class="keyword">for</span> i=1:n
    <span class="comment">% encode the filter output for each input signal using ASDM</span>
    [z(i,:), voltage(i,:)] = asdm_encode(v(i,:),t,bias,delta,kappa);
<span class="keyword">end</span>
</pre><p>Identify three filters.</p><pre class="codeinput">[h_rec, total_spikes_used] = identify_h_asdm_mimo(t, t_filt, u, W, L, bias,<span class="keyword">...</span>
    delta, kappa, z);
</pre><pre class="codeoutput">Number of spikes needed to invert the matrix: 126
Number of spikes used: 131
</pre><p>Generate Fig.11 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig11(T1,T2,f,L,bias,delta,dt,t_filt,h,Ph,t,u,v,<span class="keyword">...</span>
            z,voltage,h_rec,total_spikes_used);
</pre><img vspace="5" hspace="5" src="cim_demo_09.png" alt=""> <p>Get running time for Fig.11.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 11: '</span>, toc(tic_fig11));
</pre><pre class="codeoutput">Running time for Fig. 11: 0' 27.4"
</pre><h2>Reproduce Fig.12 of [1]<a name="67"></a></h2><p>The channel identification methodology can be generalized and extended to other RKHSs. In particular, we consider the Paley-Wiener space in which functions have finite energy and finite frequency support between [-W, W]. The space of trigonometric polynomials can be considered as a finite dimensional discretization of the Paley-Wiener space. In contrast to functions in the space of trigonometric polynomials, functions in the Paley-Wiener space are not periodic. The convolution is defined over the entire real line.</p><pre class="codeinput">tic_fig12 = tic;                                                     <span class="comment">% start the demo timer for Fig. 12</span>
</pre><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 19871127);
</pre><p>Specify the Ideal IAF neuron.</p><pre class="codeinput">delta = 0.007;                                                       <span class="comment">% set the threshold</span>
bias  = 0.35;                                                        <span class="comment">% set the bias</span>
kappa = 1;                                                           <span class="comment">% set capacitance</span>
</pre><p>Create the input signal.</p><pre class="codeinput">dt  = 1e-6;                                                          <span class="comment">% set the time step, [s]</span>
t   = -0.25:dt:0.15;                                                 <span class="comment">% set the time course of the input signals</span>
f   = 100;                                                           <span class="comment">% set the input signal bandwidth, [Hz]</span>
W   = 2*pi*f;                                                        <span class="comment">% calculate the bandwidth in radians</span>
Ts  = pi/W;                                                          <span class="comment">% calculate the sampling period</span>
n   = 5;                                                             <span class="comment">% set the number of input signals</span>
Ns  = floor((t(end)-t(1))/Ts);                                       <span class="comment">% find the number of signal samples</span>
u   = zeros(n,length(t));                                            <span class="comment">% allocate a matrix for input signal</span>
ukT = randn(Ns, n);                                                  <span class="comment">% get samples from a Gaussian distribution</span>
<span class="keyword">for</span> i=1:n
    <span class="keyword">for</span> k=1:Ns
        u(i,:) = u(i,:) + ukT(k,i)*sinc(W*(t-t(1)-k*Ts)/pi);         <span class="comment">% the first sample is zero</span>
    <span class="keyword">end</span>
    u(i,:) = u(i,:)/max(abs(u(i,:)));
<span class="keyword">end</span>
</pre><p>Specify the filter h to be used.</p><pre class="codeinput">t_filt = -0.05:dt:0.15;                                              <span class="comment">% set time course of the filter</span>
h = filter(t_filt,T1,T2,a);                                          <span class="comment">% get the filter</span>
</pre><p>Compute the filter projection. The reproducing kernel of the Paley-Weiner space is the well-known sinc function. To compute the filter projection correctly, the time course of the sinc kernel is set to two times longer than that of the filter (so that it covers both negative and positive time). The reason to do so is that the sinc kernel is neither causal nor periodic. Due to aperiodicity, the filter projection is computed using the stand convolution rather than the circular convolution.</p><pre class="codeinput">t_sinc = dt*(-numel(t_filt):numel(t_filt));                          <span class="comment">% compute the time vector for the sinc kernel</span>
K  = W/pi*sinc(W*t_sinc/pi);                                         <span class="comment">% get the sinc kernel</span>
Ph = dt*fftfilt( h, K );                                             <span class="comment">% get the filer projection by convolving h and K</span>
Ph = Ph(end-numel(t_filt)+1:end);                                    <span class="comment">% get the proper part of the convolution result</span>
</pre><p>Filter the input signals. Because the input signals are all finite, the filter output is not computed correctly at boundaries. Use only that part of the filter output, for which the convolution is computed correctly. The input signals and the time course for input signals are truncated accordingly.</p><pre class="codeinput">idx = 1+numel(find(t_filt&gt;=0 &amp; t_filt&lt;=0.1));                        <span class="comment">% find the first index for which the filter output is computed correctly</span>
t_simul = t(idx:end);                                                <span class="comment">% get the corresponding time course</span>
u_simul = u(:,idx:end);                                              <span class="comment">% get the corresponding input signals</span>
v_simul = zeros(size(u_simul));                                      <span class="comment">% allocate a matrix for filter output</span>
<span class="keyword">for</span> i=1:n
    v = dt*fftfilt(h(t_filt&gt;=0),u(i,:));                             <span class="comment">% compute the filter output</span>
    v_simul(i,:) = v(idx:end);                                       <span class="comment">% get the proper part of the filter output</span>
<span class="keyword">end</span>
</pre><p>Encode the filter output v.</p><pre class="codeinput">s = zeros(n, length(t_simul));                                       <span class="comment">% allocate a matrix for the spike sequence</span>
voltage = zeros(n, length(t_simul));                                 <span class="comment">% allocate a matrix for the membrane voltage</span>
<span class="keyword">for</span> i=1:n
    <span class="comment">% encode the output of the filter using an ideal IAF neuron</span>
    [s(i,:), voltage(i,:)] = ideal_iaf_rt_encode(<span class="keyword">...</span>
        v_simul(i,:), t_simul, bias,delta,kappa,<span class="string">'RandomInit'</span>,false);
<span class="keyword">end</span>
</pre><p>Identify the filter</p><pre class="codeinput">tau_1 = -0.025; tau_2 = 0.125;                                       <span class="comment">% set a window for faithful identification</span>
[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(t_simul, t_filt,<span class="keyword">...</span>
     u_simul, W, Inf, bias, delta, kappa, s, <span class="string">'Tau'</span>, [tau_1 tau_2]);
</pre><pre class="codeoutput">Number of spikes used: 72
</pre><p>Generate Fig.12 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig12(T1,T2,tau_1,tau_2,f,bias,delta,dt,t_filt,h,Ph,<span class="keyword">...</span>
        t_simul,u_simul,v_simul,s,voltage,h_rec,total_spikes_used);
</pre><img vspace="5" hspace="5" src="cim_demo_10.png" alt=""> <p>Get running time for Fig.12.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 12: '</span>, toc(tic_fig12));
</pre><pre class="codeoutput">Running time for Fig. 12: 0' 35.4"
</pre><h2>Reproduce Fig.13 of [1]<a name="78"></a></h2><p>We revisit what has been shown in Fig. 5 and Fig. 6 in [1], and show that the methodology employed before can be extended within an appropriate mathematical setting to I/O systems with noisy measurements.</p><pre class="codeinput">tic_fig13 = tic;                                                     <span class="comment">% start the demo timer for Fig.13</span>
</pre><p>Fix the state of randn() and rand() explicitly to ensure reproducible results.</p><pre class="codeinput">randn(<span class="string">'state'</span>, 27111987);
rand(<span class="string">'state'</span>, 19550206);
</pre><p>Specify the Ideal IAF neuron with random thresholds.</p><pre class="codeinput">delta = 0.005;                                                       <span class="comment">% set the threshold</span>
bias  = 0.3;                                                         <span class="comment">% set the bias</span>
kappa = 1;                                                           <span class="comment">% set the capacitance</span>
sigma_delta = 10/100;                                                <span class="comment">% set the variance of random thresholds</span>
</pre><p>Generate the input signals.</p><pre class="codeinput">L  = 5;                                                              <span class="comment">% set the order of the space (number of basis)</span>
f  = 25;                                                             <span class="comment">% set the input signal bandwidth, [Hz]</span>
W  = 2*pi*f;                                                         <span class="comment">% calculate the bandwidth in radians</span>
T  = 2*pi*L/W;                                                       <span class="comment">% calculate the period of the input signal</span>
n  = 2;                                                              <span class="comment">% set the number of input signals</span>
dt = 1e-5;                                                           <span class="comment">% set the time step, [s]</span>
t  = -T/2:dt:T/2;                                                    <span class="comment">% set the time course of the input signals, [s]</span>
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              <span class="comment">% generate random signal coefficients</span>
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            <span class="comment">% u_{-l} = conj(u_l)</span>
u_l(:,L+1) = randn(n,1);                                             <span class="comment">% make the DC-term real</span>
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,<span class="string">'Normalize'</span>);      <span class="comment">% synthesize the input signals</span>
</pre><p>Create the filter and Compute the filter projection.</p><pre class="codeinput">t_filt = -T/4:dt:T*3/4;                                              <span class="comment">% set the time course of the filter, [s]</span>
h      = filter(t_filt,T1,T2,a);                                     <span class="comment">% create the filter</span>
K      = tri_ker( t_filt-t_filt(1), L, W, T);                        <span class="comment">% compute the reproducing kernel K</span>
Ph     = dt*cconv(h,K,numel(t_filt));                                <span class="comment">% find the projection Ph by convolving h with K</span>
</pre><p>Filter the input signals.</p><pre class="codeinput">v = zeros(size(u));                                                  <span class="comment">% allocate a matrix for filter output</span>
<span class="keyword">for</span> i=1:n
    v(i,:) = dt*cconv(h(t_filt&gt;=0),u(i,:),numel(t));                 <span class="comment">% convolve each input signal with h</span>
<span class="keyword">end</span>
</pre><p>Encode the filter output.</p><pre class="codeinput">s = zeros(size(u));                                                  <span class="comment">% allocate a matrix for the spike train</span>
voltage = zeros(size(u));                                            <span class="comment">% allocate a matrix for the membrane voltage</span>
delta_v = cell(n,1);                                                 <span class="comment">% allocate a vector for random thresholds</span>
<span class="keyword">for</span> i=1:n
    <span class="comment">% encode the output of the filter using an ideal IAF neuron</span>
    [s(i,:), voltage(i,:), delta_v{i}] = ideal_iaf_rt_encode(<span class="keyword">...</span>
        v(i,:), t, bias, delta, kappa, <span class="string">'DeltaVar'</span>,sigma_delta*delta);
<span class="keyword">end</span>
</pre><p>Identify the filter.</p><pre class="codeinput">[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(<span class="keyword">...</span>
    t, t_filt, u, W, L, bias, delta, kappa, s,<span class="string">'RandomThreshold'</span>,true);
</pre><pre class="codeoutput">Number of spikes needed: 12
Number of spikes used: 26
</pre><p>Generate Fig.13 of [1].</p><pre class="codeinput">figure(<span class="string">'Color'</span>,<span class="string">'White'</span>,<span class="string">'Position'</span>,[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,<span class="keyword">...</span>
        h,Ph,t,u,v,s,voltage,delta_v,h_rec,total_spikes_used);
</pre><img vspace="5" hspace="5" src="cim_demo_11.png" alt=""> <p>Get running time for Fig.13.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Running time for Fig. 13: '</span>, toc(tic_fig13));
</pre><pre class="codeoutput">Running time for Fig. 13: 0' 19.5"
</pre><p>Get demo time.</p><pre class="codeinput">cim_utility.runtime(<span class="string">'Demo Time: '</span>, toc(tic_demo));
</pre><pre class="codeoutput">Demo Time: 3' 23.6"
</pre><h2>Reference<a name="89"></a></h2><div><ol><li>A. A. Lazar and Y. B. Slutskiy, Channel Identification Machines, Journal of Computational Intelligence and Neuroscience, pp.1-20, vo1. 2012, July, 2012.</li><li>E.H. Adelson and J R. Bergen, Spatiotemporal energy models for the perception of motion, Journal of the Optical Society of America, Vol. 2(2),1985</li></ol></div><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Channel Identification Machines
% This demo illustrates a formal methodology for identifying a channel in a
% system consisting of a communication channel in cascade with an asynchronous
% sampler. In particular, the channel is modeled as a multidimensional filter,
% while models of asynchronous sampler are taken from neuroscience and
% communications and includes integrate-and-fire (IAF) neurons, asynchronous
% delta-sigma modulators (ASDM), and general oscillators in cascade with
% zero-crossing detectors.
%
% The code below reproduces results presented in [1] and can be used to
% generate Figs. 5-9 and Figs. 11-13 in [1]. The employed filter was taken from
% [2].
%
% The code is structured as follows. First, we present a step-by-step demo of
% Fig.5:
% (1) encode input signals
% (2) specify filter(s)
% (3) filer input signal(s)
% (4) encode filter output using an asynchronous sampler
% (5) identify the filter(s)
%
% We provide the code for each step together with the code for plotting the
% results. Then we declare functions for each of the above steps and package
% these functions into a MATLAB class 'cim_utility' for repetitive usage. The
% script for reproducing Figs. 6-9 and Figs. 11-13 is contained in that MATLAB
% class.
%
% * _Author: Yevgeniy B. Slutskiy <ys2146@columbia.edu>_
% * _Revision Author: Chung-Heng Yeh <chyeh@ee.columbia.edu>_
% * _Bionet Group, Columbia University_
% * _Copyright 2012-2014 Yevgeniy B. Slutskiy and Chung-Heng Yeh_
%% Initialize the demo
clc; clear all; close all;                                           % reset the MATLAB workspace
set(0,'defaulttextinterpreter','Latex');                             % set the default text interpreter to latex
addpath('../../cim');                                                % set the default path of CIM functions

tic_demo = tic;                                                      % start the demo timer
tic_fig5 = tic;                                                      % start the demo timer for Fig. 5
%%
% Define function handles for repetitive usage
e_l = @(m,t,L,W,T) exp(1j*m*W/L*t)/sqrt(T);                          % declare basis of the RKHS of trigonometric polynomials
filter = @(t,T1,T2,a) (t>=T1 & t<T2).*(3*a*exp(-a*t)...              % the filter taken from [2]
          .*((a*t).^3/factorial(3)-(a*t).^5/factorial(5)));
tri_ker = @(t,L,W,T) (2*L+1)/T*sinc((2*L+1)*W/(2*L)*t/pi)...         % kernel of the RKHS
           ./sinc(W/(2*L)*t/pi);
%% Specify the Ideal IAF neuron
delta = 0.005;                                                       % set the threshold
bias  = 0.3;                                                         % set the bias
kappa = 1;                                                           % set the capacitance
sigma_delta = 0;                                                     % set the variance of random thresholds
%% Create the band-limited Stimulus
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 27111987);
rand('state', 19550206)
%%
% Specify the order L and bandwidth W for the space of trigonometric
% polynomials
L = 5;                                                               % set the order of the space (number of exponentials)
f = 25;                                                              % set the input signal bandwidth, [Hz]
W = 2*pi*f;                                                          % calculate the bandwidth in radians
T = 2*pi*L/W;                                                        % calculate the period of the input signal
%%
% Synthesize an input signal u(t) from random coefficients u_l, l=-L,...,L.
% Note that u is defined on an interval [-T/2, T/2]. However, MATLAB assumes
% that the signal is defined on [0,T] when using the Fourier transform. To fix
% this, ifftshift is used to get the correct result. Since the signal u(t) is
% real, u_{-l} = conj(u_l), i.e., positive Fourier coefficients are complex
% conjugates of the negative coefficients and the zero-frequency, or DC term,
% is real (fundamental result of the Fourier transform).
dt = 1e-5;                                                           % set the time step, [s]
t  = -T/2:dt:T/2;                                                    % set the time course of the signal
u_l = (randn(1,2*L+1)+1i*randn(1,2*L+1));                            % generate random signal coefficients
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            % u_{-l} = conj(u_l)
u_l(:,L+1) = randn(1,1);                                             % DC-term is real
u_l_pad = [u_l(L+1:end) zeros(1,numel(t)-2*L-1) u_l(1:L)];           % set the frequency component outside bandwidth to zero
u = real(ifftshift(ifft(u_l_pad)))/sqrt(T)*numel(t);                 % synthesize the signal using inverse Fourier transform
u = u/max(abs(u));                                                   % normalize the signal
%% Specify the filter _h_ to be used
% Generate a filter h according to Adelson and Bergen [2]. h has a temporal
% support on the interval [T1, T2] with T2-T1<T. However, since the filter
% projection is periodic with period T, the filter is defined on
% [-T/4, 3*T/4] with zero response outside [T1, T2] for comparison
% purposes.
T1 = 0; T2 = 0.1;                                                    % specify T1 and T2
a = 200;                                                             % set the filter parameter
t_filt = -T/4:dt:T*3/4;                                              % set the time course of the filter, [s]
h = filter(t_filt,T1,T2,a);
%% Compute the projection Ph onto the RKHS
% Generate the reproducing kernel for the space of trigonometric polynomials
% (see Def. 1 in [1]). Since functions in the RKHS are periodic, use the
% circular convolution to compute Ph
K  = tri_ker(t_filt-t_filt(1),L,W,T);                                % get the reproducing kernel
Ph = dt*cconv(h,K,numel(t_filt));                                    % find Ph by convolving h with K
%%
% Plot the filter h and its projection Ph.
figure('Color','White','Position',[0 0 1000 800]);
    plot(t_filt,h,'REPLACE_WITH_DASH_DASHk',t_filt,Ph,'r');
    xlabel('Time, [s]');ylabel('Amplitude');xlim([t_filt(1)  t_filt(end)]);
    title('Filter and its projection');
    legend('$h$','$\mathcal{P}h$')
%% Filter the input signal
% Similarly, use circular convolution to comptue the filter output. Use only
% the causal part of the filter.
v = dt*cconv(h(t_filt>=0),u,numel(u));                               % convolve u with h
%%
% Plot the input signal and the filter output.
figure('Color','White','Position',[0 0 1000 800]);
    subplot(2,1,1);
        plot( t-t(1), u );
        ylabel('Amplitude');xlim([0 t(end)-t(1)]);set(gca,'xticklabel',[]);
        title('(a)$\qquad$Input signal u(t)');
        legend(['$\Omega = 2\pi\cdot$' num2str(f) 'rad/s, $L = ' num2str(L) '\quad$'],...
                'location','East');
    subplot(2,1,2);
        plot( t-t(1), v );
        ylabel('Amplitude');xlim([0 t(end)-t(1)]);xlabel('Time, [s]')
        title('(b)$\qquad$Filter Output v(t)');
%% Encode the filter output  with an IAF neuron
% The integrate-and-fire (IAF) neuron is used as an instance of an asynchronous
% sampler, and exemplifies the encoding process in which the filter output is
% encoded into a spike sequence. Although the threshold is constant in this
% case, a more general implementation with random thresholds is provided below.
spikes  = zeros(size(t));                                            % allocate a vector for the spike train
voltage = zeros(size(t));                                            % allocate a vector for the membrane voltage
delta_v = delta + sigma_delta*randn();                               % allocate a vector for random thresholds
voltage(1) = 0.9*delta_v*rand();                                     % initialize the membrane voltage
%%
% Perform numerical integration using the trapezoidal method.
for i = 2:numel(t)
    % update the membrane voltage
    voltage(i) = voltage(i-1) + dt/kappa*(bias+0.5*(v(i)+v(i-1)));
    % if above threshold
    if voltage(i) >= delta_v(end)
        voltage(i) = 0;                                              % reset the membrane voltage
        spikes(i)  = 1;                                              % record spike
        delta_v    = [delta_v delta+sigma_delta*randn()];            % get a new random threshold
    end
end
%%
% Plot the encoding result.
figure('Color','White','Position',[0 0 1000 800]);
    subplot(311);
        plot(t-t(1),u);
        ylabel('Amplitude');xlim([0 t(end)-t(1)]);set(gca,'xticklabel',[]);
        title('(a)$\qquad$Input signal u(t)');
        legend(['$\Omega = 2\pi\cdot$' num2str(f) 'rad/s, $L = ' num2str(L) '\quad$'],...
                'location','East');
    subplot(312);
        plot(t-t(1), voltage,'-b');
        hold on; plot( [0 t(end)-t(1)], delta*ones(1,2),'REPLACE_WITH_DASH_DASHr');
        hold on; plot(t(logical(spikes))-t(1), delta_v(1:end-1),'or',...
                      'linewidth', 1, 'markersize',6, 'markerfacecolor','r');
        ylabel('Membrane Potential');set(gca,'xticklabel',[]);
        title('(b)$\qquad$Integrator output vs. Time');
        legend('$\int_{t_k}^{t}(u\ast h)(s)ds,\,\forall k\qquad$',...
               ['$\delta = ' num2str(delta) '$'], ...
               '$\int_{t_k}^{t}(u\ast h)(s)ds=\delta$','Location','southeast');
        axis([0 t(end)-t(1) -0.1*delta 1.2*delta]);
    subplot(313);
        stem(t(spikes==1)-t(1), 1.1*ones(size(find(spikes==1))), '^k', 'filled');
        box on; set(gca,'yticklabel',[],'ytick',[]);
        title('(c)$\qquad$IAF spike train for u(t)');
        xlabel('Time, [s]'); axis([0 t(end)-t(1)  0 1.2]);
        legend(['Spikes, $n = ' num2str(sum(spikes),'%3.0f') '\quad$'],...
                'Location','East');
%% Recover the filter
% The identification algorithm is based on Lemma 1 and Lemma 2 in [1]. The
% notation follows [1].
tk = t(spikes==1)';                                                  % get the spike times
total_spikes_used = numel(tk)-1;                                     % compute the number of spikes used for identification
%%
% Compute the measurement vector q (see Sec. 3.1 in [1]).
q = kappa*delta - bias*diff(tk);                                     % Eq.(2) in [1]
%%
% Compute the Phi matrix. Since u_{-l} = conj(u_l) for real signals,
% only half of the matrix needs to be computed. Note that 'l' in Eq.(7)
% is replaced by 'm' to avoid confusion between '1' and 'l'.
Phi = zeros(total_spikes_used,2*L+1);                                % allocate Phi matrix
u_l = fft(u)*sqrt(T)/numel(u);                                       % reconstruct the signal coefficients
for m=-L:0
    if m == 0
        Phi(:,L+1) = u_l(1)*diff(tk);                                % the DC component
    else
        Phi(:,m+L+1) = u_l(end+m+1)*sqrt(T)/(1j*m*W/L)*...
                       (e_l(m,tk(2:end),L,W,T)-e_l(m,tk(1:end-1),L,W,T));
    end
end
Phi(:,L+2:end) = conj(Phi(:,L:-1:1));
%%
% Recover the *h* vector by multiplying the pseudo inverse of Phi with q. A
% cutoff of 1e-9 is set to eliminate infinitesimal singular values.
bold_h = transpose(pinv(Phi,1e-9)*q);                                % Note that bold_h is a column vector
%%
% Reconstruct the projection of the filter Ph. The reconstruction algorithm is
% based on the inverse Fourier transform, and is similar to what has been shown
% for generating  an input signal. For convenience, the reconstruction
% algorithm is implemented as a function.
h_rec = cim_utility.synthesizeSignal(t,t_filt,bold_h,L,T);
%% Reproduce Fig.5 of [1]
% The script for plotting Fig. 5 of [1] is wrapped in a function to save space.
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,...
        h,Ph,t,u,v,spikes,voltage,{delta_v},h_rec,total_spikes_used);
%%
% Get running time for Fig.5.
cim_utility.runtime('Running time for Fig. 5: ', toc(tic_fig5));
%% Reproduce Fig.6 of [1]
% Next, we demonstrate the identification of the filter projected onto the
% RKHS with bandwidth f=100Hz and order L=20.
tic_fig6 = tic;                                                      % start the demo timer for Fig. 6
%%
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 27111987);
rand('state', 19550206);
%%
% Generate the input signals.
L  = 20;                                      	                     % set the order of the space (number of basis)
f  = 100;                                                            % set the input signal bandwidth, [Hz]
W  = 2*pi*f;                                                         % calculate the bandwidth in radians
T  = 2*pi*L/W;                                                       % calculate the period of the input signal
n  = 4;                                                              % set the number of input signals
dt = 1e-5;                                                           % set the time step, [s]
t  = -T/2:dt:T/2;                                                    % set the time course of the input signals, [s]
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              % generate random signal coefficients
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            % u_{-l} = conj(u_l)
u_l(:,L+1) = randn(n,1);                                             % make the DC-term real
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,'Normalize');      % synthesize the input signals
%%
% Create the filter and Compute the filter projection.
t_filt = -T/4:dt:T*3/4;                                              % set the time course of the filter, [s]
h      = filter(t_filt,T1,T2,a);                                     % create the filter
K      = tri_ker( t_filt-t_filt(1), L, W, T);                        % get the reproducing kernel K
Ph     = dt*cconv(h,K,numel(t_filt));                                % find the projection Ph by convolving h with K
%%
% Filter the input signals.
v = zeros(size(u));                                                  % allocate a matrix for the filter output
for i=1:n
    v(i,:) = dt*cconv(h(t_filt>=0),u(i,:),numel(t));                 % convolve each input signal with h
end
%%
% Encode the filter output.
s = zeros(size(u));                                                  % allocate a matrix for the spike train
voltage = zeros(size(u));                                            % allocate a matrix for the membrane voltage
delta_v = cell(n,1);                                                 % allocate a vector for random thresholds
for i=1:n
    % encode the output of the filter using an ideal IAF neuron
    [s(i,:), voltage(i,:), delta_v{i}] = ideal_iaf_rt_encode(...
        v(i,:), t, bias, delta, kappa);
end
%%
% Identify the filter.
[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(...
    t, t_filt, u, W, L, bias, delta, kappa, s);
%%
% Generate Fig.6 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,...
        h,Ph,t,u,v,s,voltage,delta_v,h_rec,total_spikes_used);
%%
% Get running time for Fig.6.
cim_utility.runtime('Running time for Fig. 6: ', toc(tic_fig6));
%% Reproduce Fig.7 of [1]
% Now, we consider a special case when the channel does not alter the input
% signal, i.e., when the filter is the Dirac delta function.
tic_fig7 = tic;                                                      % start the demo timer for Fig. 7
%%
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 19871127);
rand('state', 19550206);
%%
% Generate the input signals.
L  = 10;                                      	                     % set the order of the space (number of basis)
f  = 50;                                                             % set the input signal bandwidth, [Hz]
W  = 2*pi*f;                                                         % calculate the bandwidth in radians
T  = 2*pi*L/W;                                                       % calculate the period of the input signal
n  = 2;                                                              % set the number of input signals
dt = 1e-5;                                                           % set the time step, [s]
t  = -T/2:dt:T/2;                                                    % set the time course of the input signals, [s]
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              % generate random signal coefficients
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            % u_{-l} = conj(u_l)
u_l(:,L+1) = randn(n,1);                                             % make the DC-term real
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,'Normalize');      % synthesize the input signals
%%
% Specify the filter as the Dirac delta fcuntion.
t_filt = -T/4:dt:T*3/4;                                              % set the time course of the filter, [s]
d      = ( abs(t_filt) < dt/2 )/dt;                                  % specify the filter as the Dirac delta function
Ph     = tri_ker( t_filt, L, W, T);                                  % the filter projection is simply the kernel of the space
%%
% Filter the input signal. Since the filter is the Dirac delta function, the
% filter output is simply a copy of the input signal.
v = u;                                                               % set the filter output equal to the input
%%
% Encode the filter output.
s = zeros(size(u));                                                  % allocate a matrix for the spike train
voltage = zeros(size(u));                                            % allocate a matrix for the membrane voltage
delta_v = cell(n,1);                                                 % allocate a vector for random thresholds
for i=1:n
    % encode the output of the filter using an ideal IAF neuron
    [s(i,:), voltage(i,:), delta_v{i}] = ideal_iaf_rt_encode(...
        v(i,:), t, bias, delta, kappa);
end
%%
% Identify the filter.
[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(...
    t, t_filt, u, W, L, bias, delta, kappa, s);
%%
% Generate Fig.7 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,...
        d,Ph,t,u,v,s,voltage,delta_v,h_rec,total_spikes_used);
%%
% Get running time for Fig.7.
cim_utility.runtime('Running time for Fig. 7: ', toc(tic_fig7));
%% Reproduce Fig.8 of [1]
% Now, we consider a circuit comprised of a channel in cascade with a nonlinear
% dynamical system that has a stable limit cycle. In particular, the employed
% nonlinear dynamic system belongs to the family of van der Pol oscillator.
tic_fig8 = tic;                                                      % start the demo timer for Fig. 8
%%
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 19871127);
rand('state', 19550206);
%%
% Generate the input signal.
L  = 25;                                                             % set the order of the space (number of exponentials)
f  = 50;                                                             % set the input signal bandwidth, [Hz]
W  = 2*pi*f;                                                         % calculate the bandwidth in radians
T  = 2*pi*L/W;                                                       % calculate the period of the input signal
n  = 4;                                                              % set the number of input signals
dt = 2e-6;                                                           % set the time step, [s]
t  = -T/2:dt:T/2;                                                    % set the time course of the input signals, [s]
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              % generate random signal coefficients
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            % the positive and negative component is conjugate to each other
u_l(:,L+1) = randn(n,1);                                             % set DC-term to real
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,'Normalize');      % synthesize the input signals
%%
% Create the filter and Compute the filter projection.
t_filt = -T/4:dt:T*3/4;                                              % set the time course of the filter, [s]
h      = filter(t_filt,T1,T2,a);                                     % create the filter
K      = tri_ker( t_filt-t_filt(1), L, W, T);                        % get the reproducing kernel K
Ph     = dt*cconv(h,K,numel(t_filt));                                % find the projection Ph by convolving h with K
%%
% Filter the input signal.
v = zeros(size(u));                                                  % allocate a matrix for the filter output
for i=1:n
    v(i,:) = dt*cconv(h(t_filt>=0),u(i,:),numel(t));                 % convolve each input signal with h
end
%%
% Specify the van der Pol oscillator. Note that the oscillator parameters are
% specified with time unit as millisecond. As a result, the time course of the
% oscillator is converted from second to millisecond.
mu   = 20;                                                           % set the dumping factor
bias = 1;                                                            % set the bias
% set the function handle for the system equation of the van der Pol oscillator
van_der_pol = @(u,y) [mu*(u+bias)*(y(1)-1/3*y(1)^3-y(2)); (u+bias)*y(1)/mu];
%%
% Find the limit cycle of the employed van der Pol oscillator. In doing so, at
% each cycle, we record the 'spike' point on the phase plane, and compare the
% 'spike' point with the previous one. When the 'spike' point converges to a
% certain point, it implies that the system oscillates on a particular limit
% cycle.
spike_y = Inf(2,1);                                                  % initialize the spike point
y = repmat([0.5; 0],1,3);                                            % initialize the state variables of the oscillator
counter = 0;                                                         % set the counter
while abs(spike_y(1) - y(1,2)) > 1e-8
    y(:,3) = y(:,2) + 1e3*dt*van_der_pol(0,y(:,2));                  % update the state variables of the oscillator
    if y(1,1) < y(1,2) && y(1,2) > y(1,3)                            % spike detection
        spike_y = y(:,2);                                            % record the spike point when spike detected
        period  = counter;                                           % record the period of the present cycle
        counter = 0;                                                 % reset the counter
    end
    y(:,1:2) = y(:,2:3);                                             % pass the current states to post states
    counter = counter + 1;                                           % increase the counter by 1
end
lc = zeros(size(y,1),period);                                        % allocate memory for the limit cycle
lc(:,1) = spike_y;                                                   % set the 'spike' point of the limit cycle
for i = 2:counter
    lc(:,i) = lc(:,i-1) + 1e3*dt*van_der_pol(0,lc(:,i-1));           % compute the limit cycle at each time step
end
%%
% Encode the filter output using the van der Pol oscillator. We provide a
% generic nonlinear encoder in which the van der Pol oscillator is embedded.
% The van der Pol oscillator can be replaced by any other dynamic system which
% has a stable limit cycle and an analytic system equation.
y1 = zeros(n,numel(t));                                              % allocate memory for the first state variable
y2 = zeros(n,numel(t));                                              % allocate memory for the second state variable
s = zeros(n,numel(t));                                               % allocate memory for the spike sequence
for i = 1:n
    rnd_init = lc(:,round(1 + period*rand));                         % set the oscillator at a random point of the limit cycle
    % encode the filter output using the van der Pol oscillator
    [s(i,:), y1(i,:), y2(i,:)] = nonlinear_sys_encode(...
        v(i,:),1e3*t,van_der_pol,rnd_init);
end
%%
% Identify the filter.
h_rec = identify_h_ideal_iaf_trig( t, t_filt, u, W, L, bias, period*dt, 1, s);
%%
% Generate Fig. 8 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig8(T1,T2,T,f,W,L,mu,bias,dt,lc,...
                         t_filt,h,Ph,t,u,v,y1,y2,s,h_rec);
%%
% Get running time for Fig.8.
cim_utility.runtime('Running time for Fig. 8: ', toc(tic_fig8));
%% Reproduce Fig.9 of [1]
% To provide intuition about the relationship between the filter and the filter
% projection, we compare the two in both time and frequency domains for several
% choices of the RKHS (different orders L and bandwidths W).
tic_fig9 = tic;                                                      % start the demo timer for Fig. 9
%%
% Specify the filter h to be used.
dt = 1e-5;                                                           % set the time step, [s]
t_filt = -1:dt:1;                                                    % set the time course of the filter
h = filter(t_filt,T1,T2,a);                                          % get the filter
%%
% Compute the filter projection onto the RKHS for multiple values of bandwidth W
% and order L.
T   = [0.2 0.5];                                                     % set the period of the space
f_v = [20 50 100];                                                   % set the bandwidth of the space
Ph_cell = cell(length(f_v), length(T));                              % allocate a cell for Ph
for i=1:numel(f_v)
    W = 2*pi*f_v(i);                                                 % calculate the bandwidth in radians
    for j = 1:numel(T)
        L = f_v(i)*T(j);                                             % set the order of the space
        K = tri_ker(t_filt,L,W,T(j));                                % get the reproducing kernel K
        Ph_cell{i,j} = dt*cconv( h, K, numel(t_filt) );              % compute the filter projection onto the kernel
    end
end
%%
% Generate Fig.9 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig9(t_filt,dt,h,Ph_cell,f_v,T);
%%
% Get running time for Fig.9.
cim_utility.runtime('Running time for Fig. 9: ', toc(tic_fig9));
%% Reproduce Fig.11 of [1]
% We now demonstrate the channel identification for a MISO circuit consisting
% of three filters in cascade with an asynchronous sigma-delta modulator.
tic_fig11 = tic;                                                     % start the demo timer for Fig. 11
%%
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 19871127);
rand('state', 19550206);
%%
% Set the  parameters of IAF neuron.
delta = 0.0025;                                                      % set the Schmitt trigger threshold
bias  = 0.9;                                                         % set the bias
kappa = 1;                                                           % set the integrator capacitance
%%
% Generate the input signals. Five sets of input signal are randomly generated.
% Each set consists of three different signals, each of which is fed into one
% of three filters.
L  = 20;                                                             % set the order of the space (number of exponentials)
f  = 100;                                                            % set the input signal bandwidth, [Hz]
W  = 2*pi*f;                                                         % calculate the bandwidth in radians
T  = 2*pi*L/W;                                                       % calculate the period of the input signal
n  = 5;                                                              % set the number of input signal sets
dt = 1e-6;                                                           % set the time step, [s]
t  = -T/2:dt:T/2;                                                    % set the time course of the input signals, [s]
u = zeros(3,length(t),n);                                            % initialize the input signals
u_l = randn(3,2*L+1,n)+1i*randn(3,2*L+1,n);                          % generate random signal coefficients
for i=1:n
    u_l(:,1:L,i) = conj(u_l(:,end:-1:end-L+1,i));                    % u_{-l} = conj(u_l)
    u_l(:,L+1,i) = randn(3,1);                                       % make DC-term real
    u(:,:,i) = cim_utility.synthesizeSignal(t-t(1),t,u_l(:,:,i),...  % synthesize the input signal
                 L,T,'normalize');
end
%%
% Create three Filters. The first one is same as considered above. The second
% one is the delayed version of the first filter. The last one is inverted
% version of the first one.
t_filt = -T/4:dt:T*3/4;                                              % set the time course of the filter, [s]
beta = 20e-3;                                                        % set the delay of the second filter
h = zeros(3,numel(t_filt));                                          % initialize the filter bank
h(1,:) = filter(t_filt,T1,T2,a);                                     % get the filter h1
h(2,:) = filter(t_filt-beta,T1,T2,a);                                % get the delayed version of h1
h(3,:) = -filter(t_filt,T1,T2,a);                                    % get the inverted version of h2
%%
% Compute the projection of three filters
K  = tri_ker( t_filt-t_filt(1), L, W, T);                            % compute the reproducing kernel K
Ph = zeros(size(h));                                                 % initialize the filter projection
for i = 1:size(h,1)
    Ph(i,:) = dt*cconv(h(i,:),K,numel(t_filt));                      % compute projection for each filter
end
%%
% Filter the input signals.
v = zeros(n,numel(t));                                               % allocate a matrix for the filter output
for i=1:n
    for j=1:size(h,1)
        % the input to the ASDM is the summation of the output of three filters
        v(i,:) = v(i,:) + dt*cconv( h(j,t_filt>=0), u(j,:,i), numel(t) );
    end
end
%%
% Encode filter output v.
z = zeros(n,numel(t));                                               % allocate a matrix for the ASDM phase
voltage = zeros(n,numel(t));                                         % allocate a matrix for the ASDM voltage
for i=1:n
    % encode the filter output for each input signal using ASDM
    [z(i,:), voltage(i,:)] = asdm_encode(v(i,:),t,bias,delta,kappa);
end
%%
% Identify three filters.
[h_rec, total_spikes_used] = identify_h_asdm_mimo(t, t_filt, u, W, L, bias,...
    delta, kappa, z);
%%
% Generate Fig.11 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig11(T1,T2,f,L,bias,delta,dt,t_filt,h,Ph,t,u,v,...
            z,voltage,h_rec,total_spikes_used);
%%
% Get running time for Fig.11.
cim_utility.runtime('Running time for Fig. 11: ', toc(tic_fig11));
%% Reproduce Fig.12 of [1]
% The channel identification methodology can be generalized and extended to
% other RKHSs. In particular, we consider the Paley-Wiener space in which
% functions have finite energy and finite frequency support between [-W, W].
% The space of trigonometric polynomials can be considered as a finite
% dimensional discretization of the Paley-Wiener space. In contrast to
% functions in the space of trigonometric polynomials, functions in the
% Paley-Wiener space are not periodic. The convolution is defined over the
% entire real line.
tic_fig12 = tic;                                                     % start the demo timer for Fig. 12
%%
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 19871127);
%%
% Specify the Ideal IAF neuron.
delta = 0.007;                                                       % set the threshold
bias  = 0.35;                                                        % set the bias
kappa = 1;                                                           % set capacitance
%%
% Create the input signal.
dt  = 1e-6;                                                          % set the time step, [s]
t   = -0.25:dt:0.15;                                                 % set the time course of the input signals
f   = 100;                                                           % set the input signal bandwidth, [Hz]
W   = 2*pi*f;                                                        % calculate the bandwidth in radians
Ts  = pi/W;                                                          % calculate the sampling period
n   = 5;                                                             % set the number of input signals
Ns  = floor((t(end)-t(1))/Ts);                                       % find the number of signal samples
u   = zeros(n,length(t));                                            % allocate a matrix for input signal
ukT = randn(Ns, n);                                                  % get samples from a Gaussian distribution
for i=1:n
    for k=1:Ns
        u(i,:) = u(i,:) + ukT(k,i)*sinc(W*(t-t(1)-k*Ts)/pi);         % the first sample is zero
    end
    u(i,:) = u(i,:)/max(abs(u(i,:)));
end
%%
% Specify the filter h to be used.
t_filt = -0.05:dt:0.15;                                              % set time course of the filter
h = filter(t_filt,T1,T2,a);                                          % get the filter
%%
% Compute the filter projection. The reproducing kernel of the Paley-Weiner
% space is the well-known sinc function. To compute the filter projection
% correctly, the time course of the sinc kernel is set to two times longer than
% that of the filter (so that it covers both negative and positive time). The
% reason to do so is that the sinc kernel is neither causal nor periodic. Due
% to aperiodicity, the filter projection is computed using the stand
% convolution rather than the circular convolution.
%
t_sinc = dt*(-numel(t_filt):numel(t_filt));                          % compute the time vector for the sinc kernel
K  = W/pi*sinc(W*t_sinc/pi);                                         % get the sinc kernel
Ph = dt*fftfilt( h, K );                                             % get the filer projection by convolving h and K
Ph = Ph(end-numel(t_filt)+1:end);                                    % get the proper part of the convolution result
%%
% Filter the input signals. Because the input signals are all finite, the
% filter output is not computed correctly at boundaries. Use only that part of
% the filter output, for which the convolution is computed correctly. The input
% signals and the time course for input signals are truncated accordingly.
idx = 1+numel(find(t_filt>=0 & t_filt<=0.1));                        % find the first index for which the filter output is computed correctly
t_simul = t(idx:end);                                                % get the corresponding time course
u_simul = u(:,idx:end);                                              % get the corresponding input signals
v_simul = zeros(size(u_simul));                                      % allocate a matrix for filter output
for i=1:n
    v = dt*fftfilt(h(t_filt>=0),u(i,:));                             % compute the filter output
    v_simul(i,:) = v(idx:end);                                       % get the proper part of the filter output
end
%%
% Encode the filter output v.
s = zeros(n, length(t_simul));                                       % allocate a matrix for the spike sequence
voltage = zeros(n, length(t_simul));                                 % allocate a matrix for the membrane voltage
for i=1:n
    % encode the output of the filter using an ideal IAF neuron
    [s(i,:), voltage(i,:)] = ideal_iaf_rt_encode(...
        v_simul(i,:), t_simul, bias,delta,kappa,'RandomInit',false);
end
%%
% Identify the filter
tau_1 = -0.025; tau_2 = 0.125;                                       % set a window for faithful identification
[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(t_simul, t_filt,...
     u_simul, W, Inf, bias, delta, kappa, s, 'Tau', [tau_1 tau_2]);
%%
% Generate Fig.12 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig12(T1,T2,tau_1,tau_2,f,bias,delta,dt,t_filt,h,Ph,...
        t_simul,u_simul,v_simul,s,voltage,h_rec,total_spikes_used);
%%
% Get running time for Fig.12.
cim_utility.runtime('Running time for Fig. 12: ', toc(tic_fig12));
%% Reproduce Fig.13 of [1]
% We revisit what has been shown in Fig. 5 and Fig. 6 in [1], and show that the
% methodology employed before can be extended within an appropriate
% mathematical setting to I/O systems with noisy measurements.
tic_fig13 = tic;                                                     % start the demo timer for Fig.13
%%
% Fix the state of randn() and rand() explicitly to ensure reproducible results.
randn('state', 27111987);
rand('state', 19550206);
%%
% Specify the Ideal IAF neuron with random thresholds.
delta = 0.005;                                                       % set the threshold
bias  = 0.3;                                                         % set the bias
kappa = 1;                                                           % set the capacitance
sigma_delta = 10/100;                                                % set the variance of random thresholds
%%
% Generate the input signals.
L  = 5;                                                              % set the order of the space (number of basis)
f  = 25;                                                             % set the input signal bandwidth, [Hz]
W  = 2*pi*f;                                                         % calculate the bandwidth in radians
T  = 2*pi*L/W;                                                       % calculate the period of the input signal
n  = 2;                                                              % set the number of input signals
dt = 1e-5;                                                           % set the time step, [s]
t  = -T/2:dt:T/2;                                                    % set the time course of the input signals, [s]
u_l = randn(n,2*L+1)+1i*randn(n,2*L+1);                              % generate random signal coefficients
u_l(:,1:L) = conj(u_l(:,end:-1:end-L+1));                            % u_{-l} = conj(u_l)
u_l(:,L+1) = randn(n,1);                                             % make the DC-term real
u = cim_utility.synthesizeSignal(t-t(1),t,u_l,L,T,'Normalize');      % synthesize the input signals
%%
% Create the filter and Compute the filter projection.
t_filt = -T/4:dt:T*3/4;                                              % set the time course of the filter, [s]
h      = filter(t_filt,T1,T2,a);                                     % create the filter
K      = tri_ker( t_filt-t_filt(1), L, W, T);                        % compute the reproducing kernel K
Ph     = dt*cconv(h,K,numel(t_filt));                                % find the projection Ph by convolving h with K
%%
% Filter the input signals.
v = zeros(size(u));                                                  % allocate a matrix for filter output
for i=1:n
    v(i,:) = dt*cconv(h(t_filt>=0),u(i,:),numel(t));                 % convolve each input signal with h
end
%%
% Encode the filter output.
s = zeros(size(u));                                                  % allocate a matrix for the spike train
voltage = zeros(size(u));                                            % allocate a matrix for the membrane voltage
delta_v = cell(n,1);                                                 % allocate a vector for random thresholds
for i=1:n
    % encode the output of the filter using an ideal IAF neuron
    [s(i,:), voltage(i,:), delta_v{i}] = ideal_iaf_rt_encode(...
        v(i,:), t, bias, delta, kappa, 'DeltaVar',sigma_delta*delta);
end
%%
% Identify the filter.
[h_rec, total_spikes_used] = identify_h_ideal_iaf_trig(...
    t, t_filt, u, W, L, bias, delta, kappa, s,'RandomThreshold',true);
%%
% Generate Fig.13 of [1].
figure('Color','White','Position',[0 0 1000 800]);
    cim_utility.plotPaperFig(T1,T2,T,f,W,L,bias,delta,sigma_delta,dt,t_filt,...
        h,Ph,t,u,v,s,voltage,delta_v,h_rec,total_spikes_used);
%%
% Get running time for Fig.13.
cim_utility.runtime('Running time for Fig. 13: ', toc(tic_fig13));
%%
% Get demo time.
cim_utility.runtime('Demo Time: ', toc(tic_demo));
%% Reference
% # A. A. Lazar and Y. B. Slutskiy, Channel Identification Machines, Journal
% of Computational Intelligence and Neuroscience, pp.1-20, vo1. 2012, July,
% 2012.
% # E.H. Adelson and J R. Bergen, Spatiotemporal energy models for the
% perception of motion, Journal of the Optical Society of America, Vol.
% 2(2),1985

##### SOURCE END #####
--></body></html>